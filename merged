package solution;


import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;
import org.apache.hadoop.filecache.DistributedCache;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class SingleWordLatLong extends Configured implements Tool {
    final static String BUSINESS_MAPPING_FILE = "yelp.business.file";
    
    public int run(String[] args) throws Exception {

        Configuration conf = this.getConf();
 
        
        String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
        
        String bus_file_name = conf.get(BUSINESS_MAPPING_FILE);
        DistributedCache.addCacheFile(new Path(bus_file_name).toUri(), conf); 
        
        Job job = new Job(conf, "Yelp Lat Long Job");
        job.setJarByClass(SingleWordLatLong.class);
    	
        job.setJobName("Single Word Lat Long Job");
        
        FileInputFormat.setInputPaths(job, new Path(otherArgs[0]));
        FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));

        
        job.setMapperClass(SingleWordMapper.class);
        job.setReducerClass(SingleWordReducer.class);        

        job.setMapOutputValueClass(IntWritable.class);
        
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(NullWritable.class);

        return (job.waitForCompletion(true) ? 0 : 1);
    }

    public static void main(String[] args) throws Exception {

        int exitCode = ToolRunner.run(new Configuration(), new SingleWordLatLong(), args);
        System.exit(exitCode);        
    }
   
}package solution;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer.Context;
import org.apache.hadoop.filecache.DistributedCache;
import org.apache.hadoop.fs.Path;

import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

/* 
 * To define a map function for your MapReduce job, subclass 
 * the Mapper class and override the map method.
 * The class definition requires four parameters: 
 *   The data type of the input key
 *   The data type of the input value
 *   The data type of the output key (which is the input key type 
 *   for the reducer)
 *   The data type of the output value (which is the input value 
 *   type for the reducer)
 */

public class SingleWordMapper extends Mapper<LongWritable, Text, Text, IntWritable> {

    //declare heap variables outside the map method
	Text busIdToSave = new Text();
	String wordToMap = null;
	IntWritable count = new IntWritable(1);
	  
	  @Override
	    protected void setup(Context context){
	        Configuration conf = context.getConfiguration();
	        wordToMap = conf.get("yelp.wordtomap");
	        if (wordToMap == null) {
	            throw new RuntimeException("Error reading the word to map");

	        }
	  }


	
  @Override
  public void map(LongWritable key, Text value, Context context)
      throws IOException, InterruptedException {

	
    String line = value.toString();
    Object obj=JSONValue.parse(line);
    JSONObject json = (JSONObject) obj;
    String reviewText = (String) json.get("text");
    String businessId = (String) json.get("business_id");
    busIdToSave.set(businessId);
    /*
     * The line.split("\\W+") call uses regular expressions to split the
     * line up by non-word characters.
     * 
     */
    for (String word : reviewText.split("\\W+")) {
      if (word.length() > 0) {
        
    	 
    	if(wordToMap.toLowerCase().equals(word.toLowerCase()))
    	{
            context.write(busIdToSave, count);
    	}    	 	  
    	
      }
    }
  }
}package solution;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.filecache.DistributedCache;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.Mapper.Context;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

/* 
 * To define a reduce function for your MapReduce job, subclass 
 * the Reducer class and override the reduce method.
 * The class definition requires four parameters: 
 *   The data type of the input key (which is the output key type 
 *   from the mapper)
 *   The data type of the input value (which is the output value 
 *   type from the mapper)
 *   The data type of the output key
 *   The data type of the output value
 */   
public class SingleWordReducer extends Reducer<Text, IntWritable, Text, NullWritable> {

	
	Text outputText = new Text();
	NullWritable nullOutput;

	Map<String, String> busMap = new HashMap<String, String>();

	  private void readBusinessMapping(String bus_file_name){
		  ///Set up the business-location mapping
	        if(bus_file_name == null){
	            throw new RuntimeException("Could not find business file in config");
	        }
	        File bus_file = new File(bus_file_name);
	        
	        BufferedReader reader;
	        try {
	        	reader = new BufferedReader(new FileReader(bus_file));
	        } catch (FileNotFoundException e) {
	            e.printStackTrace();
	            throw new RuntimeException("Could not open business file ",e);
	        }
	        String line;
	        try {
	            while((line =reader.readLine()) != null){
	            	 Object obj=JSONValue.parse(line);
	            	 JSONObject json = (JSONObject) obj;
	            	 String latitude = String.valueOf(json.get("latitude"));
	            	 String longitude = String.valueOf(json.get("longitude"));
	            	 String businessId = (String) json.get("business_id");
	            	 busMap.put(businessId, "(".concat(latitude).concat(",").concat(longitude).concat(")"));
	            	 }
	        } catch (IOException e) {
	            e.printStackTrace();
	            throw new RuntimeException("error while reading business",e);
	        }
	  }
	  
	  @Override
	    protected void setup(Context context){

	        Configuration conf = context.getConfiguration();
	        String bus_file_name = null;	      
	        
	        try {
				Path files[] = DistributedCache.getLocalCacheFiles(conf);
				
				for (Path filename : files)
				{
					System.out.println("MME Cache file:" + filename.toString());
					if(filename.getName().contains("business"))
					{
						bus_file_name = filename.toString();
					}
				}
				
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
	        
	        readBusinessMapping(bus_file_name);                
	      
	  }
	  
	  /*
	   * Reduce will be called once for each business ID that contains the word. THe reduce method should sum up the frequency that the word is used at that location and then
	   * print out that weight. Reduce is also responsible for translating the business ID into a latitude/longitude value
	   */
  @Override
	public void reduce(Text key, Iterable<IntWritable> values, Context context)
			throws IOException, InterruptedException {
		
	  int frequency = 0;
	  String latLong = busMap.get(key.toString());
	  

	  //Desired output is {location: new google.maps.LatLng(37.782, -122.443), weight: 2},
		
	  
	  
	  for (IntWritable value : values) {
		  
		  frequency+=value.get();
		}
	  
	  String outputStr = "{location: new google.maps.LatLng" + latLong + ", weight: " + frequency + "},";
	  outputText.set(outputStr);
	  
	  context.write(outputText, nullOutput);
	}
}